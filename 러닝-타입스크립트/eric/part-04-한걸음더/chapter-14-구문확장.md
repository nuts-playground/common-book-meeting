## [ 구문 확장 ]

### 핵심 한 줄 요약
    TS에서의 확장 구문들의 특징을 알고 표준, 권장사항에 맞게 사용하자 

### 구문이 뭐지?
- 구문 또는 신택스(syntax) 라고 한다.
- 프로그래밍 언어에서 프로그램의 모습, 형태, 구조가 어떻게 보이는지에 대해 정의하는 것이라고 인터넷에 나와있다.

### 그러면 타입스크립트의 구문 확장이 완전 좋은거 아닌가?!
- 그렇지 않다 이유를 알아보자.
- 자바스크립트는 계속 해서 멋지고 새로운 구문이 추가되고 있다.
  - 타입스크립트의 구문이 확장이 자바스크립트의 새로운 구문이 등장하면 충돌 가능성이 있다. 
- 언어를 처음 접하는 프로그래머가 자바스크립트가 끝나는 곳과 다른 언어가 시작하는 곳을 이해하기 어렵게 만든다.
  - 음 어렵다... 그래도 두 언어의 차이를 이해하는 건 매우 중요한 것 같다.
- 상위 집합 언어 코드를 사용하고 자바스크립트를 내보내는 트랜스파일러의 복잡성을 증가시킨다.
  - 이미 너무 어렵다 ㅋㅋㅋ 그냥 계속 써서 이런 단점은 없애자

### 어떤 구문들이 확장 되었는가?
- 클래스: 사양이 승인됨에 따라 자바스크립트 클래스에 맞춘 클래스이다.
  - useDefineForClassFields 동작과 매개변수 속성 제외하고 거의 똑같기는 하다.
    - 클래스의 필드들이 Object.defineProperty 형식으로 바뀌는데 이거는 현재 검토 중이다. 쓰면 얘기치 못한 동작이 발생할 수도 있다.
- 데코레이터: 아직 실험적인 구문이라 가능하면 쓰지 않는게 좋다 => NestJS, Angular 제외
- 열거형: 키와 값의 일반 객체와 유사한 간단한 구문 => ENUM
  - 오 난 이거 너무 좋다. 근데 이런 위와 같은 우려가 있는 줄 몰랐다.
- 네임스페이스: 코드를 구조화하고 배열하는 최신 모듈보다 앞선 해결책
  - 최신 프로젝트에서는 더 이상 사용되지 않는다고 한다.

### 1. 매개 변수 속성
- 이게 신기한게 생성자 매개 변수로 멤버 속성을 바로 정의할 수 있다.
- 생성자 매개변수 구문 안에 접근 제한자와 같이 적어주기만 하면 된다.
- 편하긴 한데 여러 문제점이 있다.
  - 런타임 확장 구문이라 일단 피하고 본다.
  - private 필드를 구성할 수 없다.
- 하지만 클래스 생성을 많이 해야 한다면 좋은 대안이 될 수 있다.
- 중요한 것은 이건 타입스크립트 고유의 것이다.

### 2. 데코레이터
- @와 함수를 붙여 데코레이터를 달 수 있다.
- ECMA 스크립트에서 아직 승인하지 않아서 지원하지 않는다.
- tsconfig 에 compilerOptions => experimentalDecorators 를 true 로 하면 사용은 가능하다.
- 아직 실험적이고 ECMA 스크리븥가 제안하는 최신 초안과도 일치하지 않는다 => 즉 비권장
- NestJS 나 Angular 에서는 데코레이터를 많이 쓰는데 제시하는 프레임워크가 제시하는 표준에 맞게 잘 사용해야 한다.

### 3. 열거형(ENUM)
- 다른 프로그래밍 언어는 연관된 값 집합인 enum, 열거형 타입을 지원한다.
- 하지만 JS 에서는 그냥 객체로 사용하고 TS 에서 추가 되었다.
- 열거형 같은 객체를 사용할 때 "해당 객체의 값 중 하나여야 한다" 를 나타내는 타입 시스템 방법이 시원하지 않다.
- keyof typeof 조합하는 방법이 있는데 예제에서 설명
- TS 에서는 enum 키워드를 제공한다.
- enum 키워드가 또 논쟁의 여지가 있는 주제라고 한다.
- "TS 에서 enum 을 사용하면 Tree-shaking 이 되지 않습니다" 라고 하는 측면에서 피하는 경우도 봤다. => 나도 그렇다.
- 근데 편하기는 엄청 편하다 ㅋㅋ
  - 열거형의 멤버들은 명시적 초깃값이 필요 없다 => 첫번째 멤버 기준으로 자동으로 숫자(인덱스)가 할당 된다.
  - 문자열 값을 사용해 공유 상수의 별칭을 지정하는데 유용하다.
  - const 열거형을 사용하면 JS로 컴파일 후 그 어떠한 코드도 남지 않게 할 수 있다.
- 장단점이 책에서 소개하는 것보다 너무 많아서 따로 추가 정리를 해야 한다.

### 4. 네임스페이스
- DT 파일 작성하지 않는 한 쓰지 말자 => 최신 자바스크립트의 모듈 체계와 일치하지 않는다. => 지난 번 .d.ts 에서 볼 수 있기 떄문에 설명한다고 한다.
- 네임스페이스는 내부 모듈이라는 개념을 가진다. => TS 에서는 네임스페이스 보다 모듈 시스템(export)을 사용하는 것을 권장한다.
- 즉 네임스페이스는 내가 내보내는 집합의 이름을 정의한다로 보면 될 것 같다.
- 네임스페이스의 모든 코드는 함수 클로저 내에서 평가 된다.
- 객체의 멤버들을 내보내기 할 때 나쁘지 않다 => 이곳 저곳에서 내보내면 var로 이름이 변환되어서 여러 기능을 타 파일에서 추가할 수 있다.
- 무한으로 중첩시킬수도 있다. => 이 말이 무엇이냐 . 으로 계속 연결하거나, namespace 안에 namespace 를 또 내보낼 수 있다. 
- DT 파일에서 유용하다
  - 오래된 어플리케이션에서 script 태그를 사용해 전역으로 사용한다.
  - export as namespace 전역이름 => 이 형식으로 모듈을 전역으로 나타낼 수 있다.
- 하지만 ECMA 모듈로 최신 표준에 맞게 재작성 할 수 있다.
- 네임스페이스와 ECMA 모듈의 차이를 알고 ECMA 모듈을 사용해 런타임 코드를 작성하자. => 이미 걷어내고 있는 움직임이다.

### 타입 전용 가져오기와 내보내기
- 타입만 내보내고 가져오는게 된다고? 제목부터 재밌다
- 매우 유용한 기능이며 자바스크립트 출력에 어떠한 복잡성도 추가하지 않는다고 한다.
- export, import 안에 type 키워드를 추가하기만 하면 된다.
- 타입 정의를 하는데 쓸 수 있고, 런타임에 사용할 수는 없다 바로 에러다.
- 근데 대부분의 TS 개발자들은 다른 구문 확장에 거부감으로 인해 잘 사용하지 않는다고 한다.

### ex) 구문 확장 - 클래스
```typescript
// 와 이게 어떻게 되는거야 진짜 신기하다.
 class Engineer {
    constructor(readonly area: string) {} // 대신 여기에 private은 못옴
}

let test = new Engineer('sidhd').area;
```

### ex) 데코레이터
```typescript
@MyDecorator     // 실험적인 기능이니까 쓰지 말자
class MyClass {}
```
### ex) 열거형
```typescript
// 약간 복잡하지만 일반적인 방식은 이렇다.
const StatusCodes = {
    'wow': 300,
    'bad': 400,
    'good': 500
} as const

type StatusCodeValue = (typeof StatusCodes)[keyof typeof StatusCodes];

// TS는 이거 지원한다.
enum StatusCodes  {
    'wow'= 300,
    'bad'= 400,
    'good'= 500
} 
```

### ex) 네임스페이스
```typescript
// Randomized 란 이름으로 value에 접근 할 수 있다.
namespace Randomized {
    const value = Math.random();
    console.log(`랜덤 벨류는 ${value}`)
}

// 두가지 방법으로 구조적으로 만들 수 있지만 어우 좀 더 많아지면 읽기 너무 어렵다. 
namespace Root.Nested {
    export const value1 = true;
}
namespace Root {
    export namespace Nested {
        export const value2 = true;
    }
}

// 이렇게 내보내기 하면
export const value: number;
export as namespace libExample

// 이렇게 받아서 value를 쓸 수 있다.
import * as libExample from '위의 경로'
const value = window.libExample.value;
```

### ex) 타입 가져오기와 내보내기
```typescript
// 런타임으로 사용할 수는 없다.
// 와 밑에 세가지 방법 다 된다.
type StringOrNumber = string | number;
export { StringOrNumber }
export { type StringOrNumber }
export type { StringOrNumber }

// 와 이렇게 받을 수 있다.
import type { StringOrNumber } from '위의 경로'
import { type StringOrNumber } from '위의 경로'
import type StringOrNumber from '위의 경로'
```

### 새로 알게된 점
- 챕터가 긍정적인 챕터인 줄 알았는데 오 안읽고 넘어갔으면 큰일날 뻔 했다 ㅋㅋ
- 매개 변수 속성은 솔직히 충격이었다. 난 절대 안쓸 것 같다.
- ENUM 키워드를 쓰지는 않지만 인덱스가 자동 할당 되는 것을 알게 되었다.
- 네임스페이스의 특징, 역할을 알게 되었다.
- 타입 가져오기, 내보내기 되는 거 너무 신기하다 ㅋㅋ 가끔 써야겠다.
