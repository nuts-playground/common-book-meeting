# Chapter01 Introduction

# 서론

<img src="./../img/os-1.1.png">

- 운영체제(OS;Operating system) : <br>

>컴퓨터 하드웨어를 관리하는 소프트웨어<br>
	응용 프로그램을 위한 기반을 제공<br>
    컴퓨터 사용자와 하드웨어 사이의 중재자 역할<br>

- OS의 근본적인 책임 : <br>
> 메모리 및 입출력 장치와 저장장치와 같은 자원들을 프로그램에 할당하는 것<br>

- 이 장의 목표 :
	1. 컴퓨터 시스템의 일반적인 구성과 인터럽트의 역할
	2. 현대 다중 처리기 컴퓨터 시스템의 구성요소
	3. 사용자 모드에서 커널 모드로의 전환
	4. 다양한 컴퓨팅 환경에서 운영체제가 어떻게 사용되는지
	5. 무료 및 고개 소스 운영체제의 예

---

# 1. 운영체제가 할 일

## 1.1 운영체제가 할 일

>다른 프로그램이 유용한 작업을 할 수 있는 환경을 제공<br>
>두 가지의 관점에서 운영체제의 역할<br>

### 1.1.1 사용자 관점

>컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.<br>
>많은 컴퓨터 사용자는 PC 앞에서 작업하고 이런 시스템은 한 사용자가 자원을 독점하도록 설계되었으며 목표는 사용자가 수행하는 작업을 최대화하는 것이다.<br>
>이런 경우 운영체제는 대부분 **사용의 용이성**을 위해 설계되고 성능에 약간 신경을 쓰고 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되느냐의 **자원의 이용**에는 전혀 신경쓰지 않는다.<br>

### 1.1.2 시스템 관점

>컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다.<br>
>운영체제는 **자원할당자(resource allocator)**로 볼 수 있다.<br>
>CPU 시간, 메모리 공간, 저장장치 공간, 입출력장치 등과 같은 **자원의 관리자**로 동작한다.<br>

### 1.1.3 운영체제의 정의

>운영체제는 어떤 목적으로 시스템이 존재하느냐에 따라 역할과 기능이 달라진다.<br>
>운영체제에는 항상 실행 중인 커널, 응용 프로그램 개발을 쉽게 하고 기능을 제공하는 미들웨어 프레임워크 및 시스템 실행 중에 시스템을 관리하는 데 도움이 되는 시스템 프로그램이 포함된다.<br>

## 1.2 컴퓨터 시스템의 구성

<img src="./../img/os.1-2.png">

>현대의 범용 컴퓨터 시스템은 여러 CPU와 장치 컨트롤러로 구성되며, 여러 장치 컨트롤러는 공통 버스로 연결된다.<br>
    장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리한다.<br>
    장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다.<br>
>일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있으며, 장치 드라이버는 장치에 대한 일관된 인터페이스를 운영체제에 제공한다.<br>

### 1.2.1 인터럽트

- 일반적인 컴퓨터 작업(입출력 수행 프로그램)

1. 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재
2. 장치 컨트롤러는 이 레지스터의 내용을 검사하여 수행할 작업을 결정
3. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작
4. 데이터 전송 완료
5. 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알림<br>
6. (읽기 요청일 때) 장치 드라이버는 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘김.<br>
(쓰기 요청일 때) 장치 드라이버는 '쓰기 완료' 또는 '장치 사용 중'과 같은 상태 정보를 반환.<br>

> 이 과정에서 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 **인터럽트**를 통해 알린다.

#### 1.2.1.1 개요
<img src="./../img/os-1-3.png">

> 인터럽트는 운영체제와 하드웨어 사이의 상호 작용 방식의 핵심이다.<br>
> 하드웨어가 CPU에 인터럽트를 발생 시키면 CPU는 인터럽트를 처리하고 다시 하던 일을 한다.

> 인터럽트는 매우 빈번히 발생해서 매우 빨리 처리되어야 한다.<br>
> 그래서 인터럽트 서비스 루틴의 주소를 제공하는 **인터럽트 벡터**가 있다.<br>

#### 1.2.1.2 구현

> 기본 인터럽트 메커니즘은 다음과 같다.

<img src="./../img/os-1-4.png">

1. CPU가 하나의 명령을 완료할 때마다 **인터럽트 요청 라인**을 감지한다.
2. (만약 컨트롤러가 CPU에 인터럽트 요청을 했다면)CPU가 감지한다.
3. 인터럽트 번호를 읽는다.
4. 이 번호를 **인터럽트 벡터**의 인덱스로 사용하여 **인터럽트 핸들러 루틴**으로 점프한다.
5. 해당 인덱스의 주소에서 실행을 시작한다.
6. 인터럽트 처리기는 작업 중 변경될 상태를 저장, 인터럽트 원인 확인, 필요한 처리를 수행하고 상태를 복원하며,*return_from_interrupt* 명령어를 실행한다.
7. CPU를 인터럽트 전으로 되돌린다.

> 위의 과정을 정리하면 다음과 같다.

1. 인터럽트 발생(raise) : 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언
2. CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch)
3. 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear).

> 최신 운영체제는 더욱 정교한 인터럽트 처리 기능이 필요하다.<br>
> 다음의 세 가지 기능은  최신 컴퓨터 하드웨어에서 CPU 및 인터럽트 컨트롤러 하드웨어에 의해 제공된다.
> 

- 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
- 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
- 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

> 대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다.<br>

- 마스크 불가능 인터럽트(nonmaskable interrupt) : 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 인터럽트 라인
- 마스킹 가능(maskable) : 장치 컨트롤러가 서비스를 요청하기 위해 사용된다.

> 벡터 방식 인터럽트 기법의 목적은 모든 인터럽트 소스를 검색하지 않고 주소를 찾기 위함이다.<br>
> 하지만 실제 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치가 있다.<br>
> 이 문제를 해결하는 일반적인 방법은 **인터럽트 체인**을 사용하는 것이다.

> 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리키고,<br>
> 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다.<br>

> 인터럽트는 **우선순위 레벨**이 존재한다.<br>
> 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고<br>
> 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다.

### 1.2.2 저장장치 구조

